!function(){"use strict";var n={4582:function(n,e,o){var i,t=o(1413),r=o(3324),a=o(5140),c=o(7313),l=o(5825),s="#FF93AD",u="#4777FE";!function(n){n[n.initial=0]="initial",n[n.grid=1]="grid",n[n.zoomOut=2]="zoomOut",n[n.connected=3]="connected",n[n.initial2=4]="initial2",n[n.zoomIn=5]="zoomIn"}(i||(i={}));var f={initial:{zoom:6.7},zoomOut:{zoom:1},initial2:{zoom:6.7},zoomIn:{zoom:10}},v=o(5647),d=o(9062),m=o(3012),p=o(9025),x=o.n(p),g=o(5987);function h(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.7,i=1-e;if(n<-1||n>1)throw new Error("Input value must be between -1 and 1.");var t=n>=0?1:-1,r=Math.abs(n);return t*(r<=e?o*r/e:o+(1-o)*(r-e)/i)*.12}var C=o(1750),b=(0,C.g)({time:0,pink:new l.Color(s),blue:new l.Color(u),blur:0,position:[.11,-.15],radius:.15,seed:0},"\n      varying vec2 vUv;\n      void main() {\n          vec4 modelPosition = modelMatrix * vec4(position, 1.0);\n          vec4 viewPosition = viewMatrix * modelPosition;\n          vec4 projectionPosition = projectionMatrix * viewPosition;\n          gl_Position = projectionPosition;\n          vUv = uv;\n        }","\n    uniform float time;\n    varying vec2 vUv;\n    uniform vec3 pink;\n    uniform vec3 blue;\n    uniform float blur;\n    uniform vec2 position;\n    uniform float radius;\n    uniform float seed;\n    #define PI 3.1415926535897932384626433832795\n\n    vec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n    //\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_2936115439(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289_2936115439(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute_2936115439(vec3 x) {\n  return mod289_2936115439(((x*34.0)+1.0)*x);\n}\n\nfloat snoise2(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289_2936115439(i); // Avoid truncation effects in permutation\n  vec3 p = permute_2936115439( permute_2936115439( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n    float circle(vec2 uv, vec2 pos, float r, float blur) {\n        float d = length(uv-pos);\n        float result = smoothstep(r, r-blur, d);\n        return result;\n    }\n\n    float map(float value, float min1, float max1, float min2, float max2) {\n        return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n    }\n\n    float rand(vec2 co){\n        return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n    }\n\n    vec4 grain(vec4 col, float scale, float amount) {\n        vec2 args = vec2(gl_FragCoord.xy*scale + rand(gl_FragCoord.xy + time)*10.0);\n        float noiseValue = snoise2(args);\n        vec3 noise = vec3(noiseValue);\n        vec3 grainColor = mix(vec3(0.0), vec3(1.0), noise * amount);\n        return vec4(mix(col.rgb, grainColor, amount), col.a);\n    }\n\n    // vec4 grain(vec4 col, float scale, float amount) {\n    //     vec2 position1 = gl_FragCoord.xy * scale + vec2(time);\n    //     vec2 position2 = gl_FragCoord.xy * scale * 1.5 + vec2(time * 1.5);\n    //     float noiseValue1 = snoise2(position1);\n    //     float noiseValue2 = snoise2(position2);\n    //     vec3 noise = vec3(noiseValue1 + noiseValue2);\n    //     vec3 grainColor = mix(vec3(0.0), vec3(1.0), noise * amount);\n    //     return vec4(mix(col.rgb, grainColor, amount), col.a);\n    // }\n    \n    void main() {\n        vec2 uv = vUv;\n        uv -= .5;\n        \n        float r = 0.5 * 0.8;\n\n        // 1. PINK CIRCLE\n        // derive pos from radius = 0.15 and angle = 30 degrees\n        // get random angle from seed\n        float angle = rand(vec2(seed+1.0)) * 2.0 * PI;\n        float speed = time * 0.3;\n        vec2 pos = vec2(0.19 * cos(angle + speed), 0.19 * sin(angle+speed));\n        vec3 pinkCircle = circle(uv, pos, r * 0.7, 0.2) * pink ;\n        vec3 col = pinkCircle;\n\n        \n        // 2. WHITE CIRCLE\n        // calculate radius using noise\n        float noiseScale2 = 10.5;\n        float noise2 = snoise2(vec2(noiseScale2 + time * 0.1));\n        float noiseRad = map(noise2, 0.0, 1.0, 0.8, 0.9);\n\n        // random start angle\n        float sAngle = rand(vec2(seed, seed * 23.7)) * 2.0 * PI;\n        pos = vec2(cos(sAngle + time*0.6), sin(sAngle + time*0.6)) * 0.15;\n        float whiteCircle = circle(uv, pos, r*noiseRad, 0.2);\n        col += whiteCircle * vec3(1.);\n\n        // 3. BLUE CIRCLE\n        float blueCircleRad = map(sin(time), -1.0, 1.0, 0.95, 1.0);\n        \n        float blueCircle = circle(uv, position, r*blueCircleRad, 0.2);\n        vec3 blueCircleFilled = blueCircle * blue;\n        \n        col = blendDifference(col, blueCircleFilled);\n        \n        // 4. PINK BACKDROP\n        float pinkBackdrop = circle(uv, vec2(0.,0.), r*1.1, 0.05) * 0.1;\n        col += pinkBackdrop * pink;\n\n        // 4.5\n        // map transparency, when colour is close to black, otherwise it's opaque\n        float alpha = smoothstep(0.0, 1.0, length(col));\n        \n        // 5. BLACK CIRCLE\n        col = clamp(col, 0., 1.);\n        float black = circle(uv, vec2(0.,0.), r, 0.1);\n        col -= vec3(black)*2.0;\n\n        // circle is fully opaque\n        alpha += black*2.0;\n\n        // 6. GRAIN\n        col = grain(vec4(col,1.), 1.4, 0.25).rgb;        \n        \n        gl_FragColor = vec4(col, alpha);\n    }\n      ");(0,a.e)({CustomMaterial:b});var y,w=o(6417),z=["i"],k=function(n){var e=n.i,o=void 0===e?0:e,i=(0,g.Z)(n,z),r=(0,c.useRef)();return(0,a.A)((function(n,e){r.current.time+=e;var o=[];o[0]=h(n.mouse.x),o[1]=h(n.mouse.y),r.current.position[0]=l.MathUtils.lerp(r.current.position[0],o[0],.1),r.current.position[1]=l.MathUtils.lerp(r.current.position[1],o[1],.1)})),(0,w.jsxs)("mesh",(0,t.Z)((0,t.Z)({},i),{},{children:[(0,w.jsx)("planeGeometry",{}),(0,w.jsx)("customMaterial",{ref:r,seed:o,toneMapped:!1,blending:l.NormalBlending,alphaTest:.1,transparent:!0})]}),b.key)},S=function(n){var e=n.from,o=n.to,i=[e,(new l.Vector3).lerpVectors((0,v.Z)(l.Vector3,(0,d.Z)(e)),(0,v.Z)(l.Vector3,(0,d.Z)(o)),.5).toArray(),o].map((function(n){return[n[0],n[1],n[2]-1.1]}));return(0,w.jsx)(m.x,{points:i,color:"white",vertexColors:[new l.Color("black"),new l.Color("#444"),new l.Color("black")]})},P=function(n){var e=n.state,o=(0,c.useMemo)((function(){for(var n,e=x()(10,10,1.4),o=[];n=e();){var i=1.4*n[0],t=1.4*n[1],r=new l.Vector3(i,t,0);if(o.push(r),o.length>=20)break}var a=new l.Vector3;o.forEach((function(n){return a.add(n)})),a.divideScalar(o.length);var c=1/0,s=0;o.forEach((function(n,e){var o=n.distanceToSquared(a);o<c&&(c=o,s=e)}));var u=o[s].clone();return o.forEach((function(n){return n.sub(u)})),[o,s]}),[]),t=(0,r.Z)(o,2),a=t[0],s=a[t[1]].toArray();return(0,w.jsx)(w.Fragment,{children:a.map((function(n,o){return(0,w.jsxs)("group",{children:[e===i.connected&&(0,w.jsx)(S,{from:s,to:n.toArray()}),(0,w.jsx)(k,{i:o,position:n})]},o)}))})},j=["args","cellColor","sectionColor","cellSize","sectionSize","followCamera","infiniteGrid","fadeDistance","fadeStrength","cellThickness","sectionThickness","side"],_=(0,C.g)({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,cellThickness:.5,sectionThickness:1,cellColor:new l.Color,sectionColor:new l.Color,infiniteGrid:0,followCamera:0},"varying vec3 worldPosition;\n   uniform float fadeDistance;\n   uniform float infiniteGrid;\n   uniform float followCamera;\n   void main() {\n     vec3 pos = position.xzy * (1. + fadeDistance * infiniteGrid);\n     pos.xz += (cameraPosition.xz * followCamera);\n     worldPosition = pos;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n   }","varying vec3 worldPosition;\n   uniform float cellSize;\n   uniform float sectionSize;\n   uniform vec3 cellColor;\n   uniform vec3 sectionColor;\n   uniform float fadeDistance;\n   uniform float fadeStrength;\n   uniform float cellThickness;\n   uniform float sectionThickness;\n   uniform float infiniteGrid;\n   float getGrid(float size, float thickness) {\n     vec2 r = worldPosition.xz / size;\n     vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n     float line = min(grid.x, grid.y) + 1. - thickness;\n     return 1.0 - min(line, 1.);\n   }\n   void main() {\n     float g1 = getGrid(cellSize, cellThickness);\n     float g2 = getGrid(sectionSize, sectionThickness);\n     float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / fadeDistance, 1.);\n     vec3 color = mix(cellColor, sectionColor, min(1.,sectionThickness * g2));\n     gl_FragColor = vec4(color, (g1 + g2) * pow(d,fadeStrength));\n     gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n     if (gl_FragColor.a <= 0.0) discard;\n     #include <tonemapping_fragment>\n     #include <encodings_fragment>\n   }"),Z=c.forwardRef((function(n,e){var o=n.args,i=n.cellColor,r=void 0===i?"#000000":i,c=n.sectionColor,s=void 0===c?"#2080ff":c,u=n.cellSize,f=void 0===u?.5:u,v=n.sectionSize,d=void 0===v?1:v,m=n.followCamera,p=void 0!==m&&m,x=n.infiniteGrid,h=void 0!==x&&x,C=n.fadeDistance,b=void 0===C?100:C,y=n.fadeStrength,z=void 0===y?1:y,k=n.cellThickness,S=void 0===k?.5:k,P=n.sectionThickness,Z=void 0===P?1:P,M=n.side,A=void 0===M?l.BackSide:M,T=(0,g.Z)(n,j);(0,a.e)({GridMaterial:_});var F={cellSize:f,sectionSize:d,cellColor:r,sectionColor:s,cellThickness:S,sectionThickness:Z},O={fadeDistance:b,fadeStrength:z,infiniteGrid:h,followCamera:p};return(0,w.jsxs)("mesh",(0,t.Z)((0,t.Z)({ref:e,frustumCulled:!1},T),{},{children:[(0,w.jsx)("gridMaterial",(0,t.Z)((0,t.Z)({transparent:!0,"extensions-derivatives":!0,side:A},F),O)),(0,w.jsx)("planeGeometry",{args:o})]}))})),M=function(n){var e=n.state;return(0,a.A)((function(n,o){if(e===i.initial)n.camera.zoom=f.initial.zoom;else if(f[i[e]]&&f[i[e]].zoom){var t=f[i[e]].zoom;n.camera.zoom+=(t-n.camera.zoom)*o*10}n.camera.updateProjectionMatrix()})),(0,w.jsxs)(w.Fragment,{children:[e===i.grid&&(0,w.jsx)(Z,{rotation:[Math.PI/2,0,0],"position-z":.1,infiniteGrid:!0,sectionSize:.25,cellThickness:1,sectionColor:"#444"}),(0,w.jsx)(P,{state:e})]})},A=function(n){var e=n.state;return(0,w.jsx)(M,{state:e})},T=o(4942),F=o(1781),O={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]},D=(0,F.Z)();function I(n){var e=(0,a.c)(n).handlePointer;return{priority:1,enabled:!0,compute:function(n,e){e.pointer.set(n.offsetX/e.size.width*2-1,-n.offsetY/e.size.height*2+1),e.raycaster.setFromCamera(e.pointer,e.camera)},connected:void 0,handlers:Object.keys(O).reduce((function(n,o){return(0,t.Z)((0,t.Z)({},n),{},(0,T.Z)({},o,e(o)))}),{}),connect:function(e){var o,i,a=n.getState(),c=a.set,l=a.events;null===(o=l.disconnect)||void 0===o||o.call(l),c((function(n){return{events:(0,t.Z)((0,t.Z)({},n.events),{},{connected:e})}})),Object.entries(null!==(i=null===l||void 0===l?void 0:l.handlers)&&void 0!==i?i:[]).forEach((function(n){var e=(0,r.Z)(n,2),o=e[0],i=e[1],t=(0,r.Z)(O[o],1)[0];D.on(t,i)}))},disconnect:function(){var e,o=n.getState(),i=o.set,a=o.events;a.connected&&(Object.entries(null!==(e=a.handlers)&&void 0!==e?e:[]).forEach((function(n){var e=(0,r.Z)(n,2),o=e[0],i=e[1],t=(0,r.Z)(O[o],1)[0];D.off(t,i)})),D.emit("disconnect"),i((function(n){return{events:(0,t.Z)((0,t.Z)({},n.events),{},{connected:void 0})}})))}}}(0,a.e)(l);var E=function(n){var e=(0,c.useState)(n),o=(0,r.Z)(e,2),i=o[0],a=o[1];return(0,c.useEffect)((function(){return D.on("props",(function(n){a(n)})),function(){D.off("props",a)}}),[]),(0,w.jsx)(A,(0,t.Z)({},i))},G={resize:function(n){var e=n.width,o=n.height,i=n.dpr;y&&y.configure({size:{width:e,height:o,updateStyle:!1},dpr:i})},init:function(n){var e=n.props,o=n.drawingSurface,i=n.width,r=n.height,c=n.pixelRatio;(y=(0,a.a)(o)).configure({events:I,size:{width:i,height:r,updateStyle:!1},dpr:c}),y.render((0,w.jsx)(E,(0,t.Z)({},e)))},dom_events:function(n){D.emit(n.eventName,n),D.on("disconnect",(function(){self.postMessage({type:"dom_events_disconnect"})}))},props:function(n){D.emit("props",n)}};self.onmessage=function(n){var e=n.data,o=e.type,i=e.payload,t=G[o];t&&t(i)},self.window={}}},e={};function o(i){var t=e[i];if(void 0!==t)return t.exports;var r=e[i]={exports:{}};return n[i](r,r.exports,o),r.exports}o.m=n,o.x=function(){var n=o.O(void 0,[742],(function(){return o(4582)}));return n=o.O(n)},function(){var n=[];o.O=function(e,i,t,r){if(!i){var a=1/0;for(u=0;u<n.length;u++){i=n[u][0],t=n[u][1],r=n[u][2];for(var c=!0,l=0;l<i.length;l++)(!1&r||a>=r)&&Object.keys(o.O).every((function(n){return o.O[n](i[l])}))?i.splice(l--,1):(c=!1,r<a&&(a=r));if(c){n.splice(u--,1);var s=t();void 0!==s&&(e=s)}}return e}r=r||0;for(var u=n.length;u>0&&n[u-1][2]>r;u--)n[u]=n[u-1];n[u]=[i,t,r]}}(),o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,{a:e}),e},o.d=function(n,e){for(var i in e)o.o(e,i)&&!o.o(n,i)&&Object.defineProperty(n,i,{enumerable:!0,get:e[i]})},o.f={},o.e=function(n){return Promise.all(Object.keys(o.f).reduce((function(e,i){return o.f[i](n,e),e}),[]))},o.u=function(n){return"static/js/"+n+".e2775f15.chunk.js"},o.miniCssF=function(n){},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.r=function(n){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.p="/",function(){var n={582:1};o.f.i=function(e,i){n[e]||importScripts(o.p+o.u(e))};var e=self.webpackChunkany_type_onboarding=self.webpackChunkany_type_onboarding||[],i=e.push.bind(e);e.push=function(e){var t=e[0],r=e[1],a=e[2];for(var c in r)o.o(r,c)&&(o.m[c]=r[c]);for(a&&a(o);t.length;)n[t.pop()]=1;i(e)}}(),function(){var n=o.x;o.x=function(){return o.e(742).then(n)}}();o.x()}();